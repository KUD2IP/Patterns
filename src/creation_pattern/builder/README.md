<h1>Строитель (Builder)</h1>

<h2>Суть паттерна</h2>

<p>
Строитель — это порождающий паттерн проектирования,
который позволяет создавать сложные объекты пошагово.
Строитель даёт возможность использовать один и тот же код 
строительства для получения разных представлений объектов.

Например, давайте подумаем о том, как создать объект <code>Ноутбук</code>.
Чтобы создать стандартный <code>Ноутбук</code>, нужно снабдить
его процессором, ОЗУ, hdd и другими компонентами.
Но что, если вы хотите ноутбук помощнее и производительнее?

Самое простое решение — расширить класс <code>Ноутбук</code>,
создав подклассы для всех комбинаций параметров ноутбука.
Проблема такого подхода — это громадное количество классов, которые вам придётся создать.
Каждый новый параметр, вроде емкости ОЗУ или количества ядер в процессоре,
заставит вас создавать всё больше и больше классов для перечисления всех возможных вариантов.

Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны.
Вы можете создать гигантский конструктор <code>Ноутбука</code>, принимающий уйму параметров 
для контроля над создаваемым продуктом. Это избавит от подклассов,
но приведёт к другой проблеме.

Большая часть этих параметров будет простаивать,
а вызовы конструктора будут выглядеть монструозно из-за длинного списка параметров.
К примеру, не каждый Ноутбук видеокарту, поэтому параметры, связанные с ней,
будут простаивать бесполезно.
</p>

<h2>Решение</h2>

<p>
Паттерн Строитель предлагает вынести конструирование объекта за пределы его собственного класса,
поручив это дело отдельным объектам, которые следует называть строителями.

Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги
(например, <code>SetProcessor</code>, <code>SetRam</code>, и другие). 
Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. 
Причём не нужно запускать все шаги, а только те, что нужны для производства объекта
определённой конфигурации.

Зачастую один и тот же шаг строительства может отличаться для разных вариаций производимых объектов.
Например, вы можете создать игровой ноутбук или офисный.

В этом случае вы можете создать несколько классов строителей,
выполняющих одни и те же шаги по-разному. 
Используя этих строителей в одном и том же строительном процессе,
вы сможете получать на выходе различные объекты.

Например, один строитель делает ноутбуки для игр,
другой для работы, третий для apple.
Код, который вызывает шаги строительства, 
должен работать со строителями через общий интерфейс, чтобы их можно было свободно взаимозаменять.
</p>

<h3>Директор</h3>
<p>
Вы можете пойти дальше и выделить вызовы методов строителя в отдельный класс,
называемый директором. В этом случае директор будет задавать порядок шагов строительства,
а строитель — выполнять их.

Отдельный класс директора не является строго обязательным.
Можно вызывать методы строителя и напрямую из клиентского кода. 
Тем не менее, директор полезен, если у вас есть несколько способов конструирования продуктов,
отличающихся порядком и наличием шагов конструирования.
В этом случае вы сможете объединить всю эту логику в одном классе.

Такая структура классов полностью скроет от клиентского кода процесс конструирования объектов.
Клиенту останется только привязать желаемого строителя к директору, 
а затем получить у строителя готовый результат.
</p>

<h3>1. Интерфейс строителя</h3>
<p>
Интерфейс строителя объявляет шаги конструирования продуктов, общие для всех видов строителей
</p>

<h3>2. Конкретные строители</h3>
<p>
Конкретные строители реализуют строительные шаги, каждый по-своему. 
Конкретные строители могут производить разнородные объекты, не имеющие общего интерфейса.
</p>

<h3>3. Продукт</h3>
<p>
Продукт — создаваемый объект. Продукты, сделанные разными строителями, не обязаны иметь общий интерфейс.
</p>

<h3>4. Директор</h3>
<p>
Директор определяет порядок вызова строительных шагов для производства той или иной конфигурации продуктов.
</p>

<h3>5. Важно</h3>
<p>
Обычно Клиент подаёт в конструктор директора уже готовый объект-строитель,
и в дальнейшем данный директор использует только его. 
Но возможен и другой вариант, когда клиент передаёт строителя через
параметр строительного метода директора. В этом случае можно каждый раз применять 
разных строителей для производства различных представлений объектов.
</p>

<h1>Применимость</h1>
<p>
<b>Когда вы хотите избавиться от «телескопического конструктора».</b>

Допустим, у вас есть один конструктор с десятью опциональными параметрами.
Его неудобно вызывать, поэтому вы создали ещё десять конструкторов с меньшим количеством параметров.
Всё, что они делают — это переадресуют вызов к базовому конструктору,
подавая какие-то значения по умолчанию в параметры, которые пропущены в них самих.
</p>

<figure class="code">
    <pre>
public class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
// ...
}
    </pre>
</figure>

<p>
<b>Такого монстра можно создать только в языках, имеющих механизм перегрузки методов, например, C# или Java.</b>

Паттерн Строитель позволяет собирать объекты пошагово, вызывая только те шаги, которые вам нужны. 
А значит, больше не нужно пытаться «запихнуть» в конструктор все возможные опции продукта.
</p>